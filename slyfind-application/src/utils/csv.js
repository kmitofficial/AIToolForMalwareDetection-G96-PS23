import fs from "fs";
import { createObjectCsvWriter } from "csv-writer";
import path from "path";

const VOL_MODULES = {
  pslist: extractPslistFeatures,
  dlllist: extractDlllistFeatures,
  handles: extractHandlesFeatures, // only for mac
  ldrmodules: extractLdrModulesFeaturesFromText,
  malfind: extractMalfindFeatures,
  modules: extractModulesFeatures,
  svcscan: extractSvcscanFeatures, // only for mac
  callbacks: extractCallbacksFeatures,
};

function extractLdrModulesFeaturesFromText(inputText) {
  try {
    const lines = inputText.split("\n");
    const headers = lines[0].split("\t");

    const ldrmodulesData = lines.slice(1).map((line) => {
      const values = line.split("\t");
      const rowData = {};

      headers.forEach((header, index) => {
        // Convert 'True'/'False' strings to actual boolean values
        rowData[header] = values[index].toLowerCase() === "true";
      });

      return rowData;
    });

    const totalModules = ldrmodulesData.length;

    return {
      "ldrmodules.not_in_load": ldrmodulesData.filter((m) => !m.InLoad).length,
      "ldrmodules.not_in_init": ldrmodulesData.filter((m) => !m.InInit).length,
      "ldrmodules.not_in_mem": ldrmodulesData.filter((m) => !m.InMem).length,
      "ldrmodules.not_in_load_avg":
        totalModules > 0
          ? ldrmodulesData.filter((m) => !m.InLoad).length / totalModules
          : 1,
      "ldrmodules.not_in_init_avg":
        totalModules > 0
          ? ldrmodulesData.filter((m) => !m.InInit).length / totalModules
          : 1,
      "ldrmodules.not_in_mem_avg":
        totalModules > 0
          ? ldrmodulesData.filter((m) => !m.InMem).length / totalModules
          : 1,
    };
  } catch (error) {
    console.error("Error reading the file:", error);
    return null;
  }
}

function extractPslistFeatures(procs) {
  // Extract unique parent process IDs (PPID)
  let ppids = new Set(procs.map((p) => p.PPID));

  // Calculate the average thread count and average handler count
  let avgThreads = procs.reduce((sum, p) => sum + p.Threads, 0) / procs.length;
  let avgHandlers = procs.reduce((sum, p) => sum + p.Handles, 0) / procs.length;

  return {
    // Number of processes
    "pslist.nproc": procs.length,
    // Number of parent processes
    "pslist.nppid": ppids.size,
    // Average thread count
    "pslist.avg_threads": avgThreads,
    // Average handler count
    "pslist.avg_handlers": avgHandlers,
  };
}

function extractDlllistFeatures(dlllist) {
  // Count the number of unique PIDs in the report
  const procs = new Set(dlllist.map((l) => l.PID)).size;

  return {
    // Total number of loaded libraries of all processes
    "dlllist.ndlls": dlllist.length,
    // Average loaded libraries per process
    "dlllist.avg_dlls_per_proc": dlllist.length / procs,
  };
}

function extractHandlesFeatures(handles) {
  const uniquePIDs = new Set(handles.map((h) => h.PID));

  return {
    // Total number of opened handles
    "handles.nhandles": handles.length,
    // Average handle count per process
    "handles.avg_handles_per_proc": handles.length / uniquePIDs.size,
    // Number of handles of type port
    // "handles.nport": handles.filter((t) => t.Type === "ALPC Port").length,
    // // Number of handles of type file
    // "handles.nfile": handles.filter((t) => t.Type === "File").length,
    // // Number of handles of type event
    // "handles.nevent": handles.filter((t) => t.Type === "Event").length,
    // // Number of handles of type desktop
    // "handles.ndesktop": handles.filter((t) => t.Type === "Desktop").length,
    // // Number of handles of type key
    // "handles.nkey": handles.filter((t) => t.Type === "Key").length,
    // // Number of handles of type thread
    // "handles.nthread": handles.filter((t) => t.Type === "Thread").length,
    // // Number of handles of type directory
    // "handles.ndirectory": handles.filter((t) => t.Type === "Directory").length,
    // // Number of handles of type semaphore
    // "handles.nsemaphore": handles.filter((t) => t.Type === "Semaphore").length,
    // // Number of handles of type timer
    // "handles.ntimer": handles.filter((t) => t.Type === "Timer").length,
    // // Number of handles of type section
    // "handles.nsection": handles.filter((t) => t.Type === "Section").length,
    // // Number of handles of type mutant
    // "handles.nmutant": handles.filter((t) => t.Type === "Mutant").length,
  };
}

function extractModulesFeatures(modules) {
  return {
    "modules.nmodules": modules.length,
  };
}

// extract_svcscan_features
function extractSvcscanFeatures(svcscan) {
  return {
    "svcscan.nservices": svcscan.length,
    "svcscan.kernel_drivers": svcscan.filter(
      (s) => s.Type === "SERVICE_KERNEL_DRIVER"
    ).length,
    "svcscan.fs_drivers": svcscan.filter(
      (s) => s.Type === "SERVICE_FILE_SYSTEM_DRIVER"
    ).length,
    "svcscan.process_services": svcscan.filter(
      (s) => s.Type === "SERVICE_WIN32_OWN_PROCESS"
    ).length,
    "svcscan.shared_process_services": svcscan.filter(
      (s) => s.Type === "SERVICE_WIN32_SHARE_PROCESS"
    ).length,
    "svcscan.nactive": svcscan.filter((s) => s.State === "SERVICE_RUNNING")
      .length,
  };
}

// extract_callbacks_features
function extractCallbacksFeatures(callbacks) {
  return {
    "callbacks.ncallbacks": callbacks.length,
    "callbacks.ngeneric": callbacks.filter(
      (c) => c.Type === "GenericKernelCallback"
    ).length,
  };
}

// extract_malfind_features
function extractMalfindFeatures(malfind) {
  const uniquePIDs = new Set(malfind.map((h) => h.PID));

  return {
    "malfind.ninjections": malfind.length,
    "malfind.commitCharge": malfind.filter((h) => h.Protection).length,
    "malfind.protection": malfind.filter((h) => h.CommitCharge).length,
    "malfind.uniqueInjections": malfind.length / uniquePIDs.size,
  };
}

function processAndWriteToCSV() {
  // Object to store all features
  let allFeatures = {};

  // Iterate over each key in VOL_MODULES
  for (const [key, extractFunction] of Object.entries(VOL_MODULES)) {
    const outputFilePath = `${path.join(__dirname, `../../src/output/${key}`)}${
      key === "ldrmodules" ? ".txt" : ".json"
    }`;
    try {
      // Read the file asynchronously
      const data = fs.readFileSync(outputFilePath, "utf8");
      if (key !== "ldrmodules") {
        const jsonData = JSON.parse(data);
        const features = extractFunction(jsonData);
        allFeatures = { ...allFeatures, ...features };
      } else {
        // Call the extract function and accumulate features
        const features = extractFunction(data);
        allFeatures = { ...allFeatures, ...features };
      }
    } catch (error) {
      console.error(`Error processing ${key}:`, error);
    }
  }

  // Define the CSV writer and header
  const csvWriter = createObjectCsvWriter({
    path: path.join(__dirname, "../../src/output/allFeatures.csv"),
    header: Object.keys(allFeatures).map((key) => ({ id: key, title: key })),
    append: false, // Set to true if you want to append to an existing file
  });

  // Write the data to the CSV file
  csvWriter
    .writeRecords([allFeatures])
    .then(() => console.log("CSV file written successfully\n"))
    .catch((err) => console.error("Error writing CSV file:", err));

  return path.join(__dirname, "../../src/output/allFeatures.csv");
}

export default processAndWriteToCSV;
