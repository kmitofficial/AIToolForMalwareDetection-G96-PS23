import { Worker } from "worker_threads";
import fs from "fs";
import path from "path";
import { exec } from "child_process";

function runModule(memdump) {
  return new Promise((resolve, reject) => {
    let modules = [
      "pslist",
      "dlllist",
      "handles",
      "malfind",
      "modules",
      "svcscan",
      "callbacks",
    ];
    let completedWorkers = 0;

    const handleWorkerCompletion = () => {
      completedWorkers++;
      if (completedWorkers === modules.length) {
        console.log("All workers completed");
        resolve();
      }
    };
    for (let i = 0; i < modules.length; i++) {
      const worker = new Worker(
        path.join(__dirname, "../../src/utils/worker.js")
      );

      // Listening for messages from the worker thread
      worker.on("message", () => {
        worker.terminate();
        handleWorkerCompletion();
      });
      worker.on("error", (error) => {
        console.error(`Error in worker: ${error}`);
        reject(error);
      });

      // Sending data to the worker thread
      let command = `${memdump}^${modules[i]}`;
      worker.postMessage(command);
    }
  });
}

async function ldr_async(memdump, plugin) {
  try {
    const fs1 = require("fs").promises;
    const command = `python3 v3/vol.py -f ${memdump} windows.${plugin}`;
    console.log("Command (Non-Worker):", plugin);
    const { stdout, stderr } = exec(command);

    const outputFile = path.join(
      __dirname,
      "../../src/output",
      `${plugin}.txt`
    );

    await fs1.writeFile(outputFile, stdout);
    console.log("\nCacheing complete\n");
    return stdout;
  } catch (error) {}
}

function listRawFilesWithSpaces() {
  let result = "";
  let memfile = "exec";
  fs.readdirSync(path.join(__dirname, `../../src/${memfile}`)).forEach(
    (file) => {
      if (
        file.endsWith(".raw") ||
        file.endsWith(".mem") ||
        file.endsWith(".dmp")
      ) {
        const filePath = path.join(__dirname, `../../src/${memfile}`, file);
        result += filePath;
      } else {
        return false;
      }
    }
  );
  return result;
}

export { listRawFilesWithSpaces, ldr_async, runModule };
